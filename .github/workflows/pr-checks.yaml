name: Pull Request Checks

on:
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened, closed]

# Global minimum permissions
permissions: read-all

jobs:
  terraform_deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read        # For checkout
      pull-requests: write  # For commenting results
      id-token: write      # For AWS authentication
    outputs:
      instance_ip: ${{ steps.get_ip.outputs.instance_ip }}
    steps:
      - uses: actions/checkout@v4.1.1

      - name: Set up AWS CLI
        uses: aws-actions/configure-aws-credentials@v4.0.2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3.0.0
        with:
          terraform_version: 1.12.1

      - name: Validate Required Secrets
        env:
          TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}
          TF_LOCK_TABLE: ${{ secrets.TF_LOCK_TABLE }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          if [ -z "$TF_STATE_BUCKET" ]; then
            echo "::error::TF_STATE_BUCKET secret is not set"
            exit 1
          fi
          if [ -z "$TF_LOCK_TABLE" ]; then
            echo "::error::TF_LOCK_TABLE secret is not set"
            exit 1
          fi
          if [ -z "$AWS_ACCESS_KEY_ID" ]; then
            echo "::error::AWS_ACCESS_KEY_ID secret is not set"
            exit 1
          fi
          if [ -z "$AWS_SECRET_ACCESS_KEY" ]; then
            echo "::error::AWS_SECRET_ACCESS_KEY secret is not set"
            exit 1
          fi
          echo "All required secrets are set"

      - name: Configure PR Test Workspace
        id: workspace
        run: |
          PR_NUMBER=$(echo $GITHUB_REF | cut -d'/' -f3)
          WORKSPACE="pr-${PR_NUMBER}"
          echo "Using workspace: $WORKSPACE"
          echo "workspace=$WORKSPACE" >> $GITHUB_OUTPUT

      - name: Create Backend Config File
        env:
          TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}
          TF_LOCK_TABLE: ${{ secrets.TF_LOCK_TABLE }}
        run: |
          cat > backend.hcl << EOF
          bucket         = "$TF_STATE_BUCKET"
          key            = "pr-environments/${{ steps.workspace.outputs.workspace }}/terraform.tfstate"
          region         = "us-east-1"
          dynamodb_table = "$TF_LOCK_TABLE"
          encrypt        = true
          EOF
          
          echo "Generated backend configuration:"
          cat backend.hcl

      - name: Terraform Init with Backend Config
        id: init
        run: |
          # Set logging to show only errors
          export TF_LOG=ERROR
          
          echo "Initializing Terraform..."
          terraform init -backend-config=backend.hcl -reconfigure -input=false 2>&1 | tee init.log
          INIT_EXIT_CODE=${PIPESTATUS[0]}
          
          if [ $INIT_EXIT_CODE -ne 0 ]; then
            echo "::error::Terraform init failed with exit code $INIT_EXIT_CODE"
            echo "Last 50 lines of init.log:"
            tail -n 50 init.log
            exit 1
          fi
          
          echo "Selecting/creating workspace..."
          if ! terraform workspace select ${{ steps.workspace.outputs.workspace }} 2>/dev/null; then
            echo "Creating new workspace: ${{ steps.workspace.outputs.workspace }}"
            terraform workspace new ${{ steps.workspace.outputs.workspace }}
          fi
          
          # Verify workspace
          CURRENT_WORKSPACE=$(terraform workspace show)
          if [ "$CURRENT_WORKSPACE" != "${{ steps.workspace.outputs.workspace }}" ]; then
            echo "::error::Failed to switch to workspace ${{ steps.workspace.outputs.workspace }}, current workspace is $CURRENT_WORKSPACE"
            exit 1
          fi
          
          echo "✅ Terraform initialization completed successfully"

      - name: Validate Terraform Files
        run: |
          echo "Validating Terraform files..."
          terraform validate 2>&1 | tee validate.log
          VALIDATE_EXIT_CODE=${PIPESTATUS[0]}
          
          if [ $VALIDATE_EXIT_CODE -ne 0 ]; then
            echo "::error::Terraform validation failed"
            echo "Validation errors:"
            cat validate.log
            exit 1
          fi
          
          echo "✅ Terraform validation successful"

      - name: Terraform Format Check
        id: fmt
        run: |
          terraform fmt -check -recursive 2>&1 | tee fmt.log
          FMT_EXIT_CODE=${PIPESTATUS[0]}
          if [ $FMT_EXIT_CODE -ne 0 ]; then
            echo "::error::Terraform format check failed. Please run 'terraform fmt -recursive' locally"
            cat fmt.log
            exit 1
          fi
          echo "✅ Terraform format check passed"

      - name: Terraform Plan
        id: plan
        env:
          TF_WORKSPACE: ${{ steps.workspace.outputs.workspace }}
        run: |
          # Set logging to show only errors
          export TF_LOG=ERROR
          
          echo "Running Terraform plan..."
          terraform plan -no-color -detailed-exitcode -input=false -out=tfplan 2>&1 | tee plan.log
          PLAN_EXIT_CODE=${PIPESTATUS[0]}
          
          # Check plan exit code
          # Exit code 0 = No changes
          # Exit code 1 = Error
          # Exit code 2 = Changes present
          if [ $PLAN_EXIT_CODE -eq 1 ]; then
            echo "::error::Terraform plan failed"
            echo "Last 50 lines of plan.log:"
            tail -n 50 plan.log
            exit 1
          fi
          
          # Store just the exit code
          echo "plan_exit_code=$PLAN_EXIT_CODE" >> $GITHUB_OUTPUT
          
          if [ $PLAN_EXIT_CODE -eq 2 ]; then
            echo "📝 Terraform plan shows changes to be applied"
          else
            echo "✅ Terraform plan shows no changes needed"
          fi

      - name: Test Infrastructure Deployment
        id: apply
        if: github.event_name == 'pull_request' && steps.plan.outcome == 'success'
        env:
          TF_WORKSPACE: ${{ steps.workspace.outputs.workspace }}
        run: |
          # Set logging to show only errors
          export TF_LOG=ERROR
          
          echo "🚀 Applying test infrastructure changes in workspace: $TF_WORKSPACE"
          terraform apply -auto-approve tfplan 2>&1 | tee apply.log
          APPLY_EXIT_CODE=${PIPESTATUS[0]}
          
          if [ $APPLY_EXIT_CODE -ne 0 ]; then
            echo "::error::Terraform apply failed"
            echo "Last 50 lines of apply.log:"
            tail -n 50 apply.log
            exit 1
          fi
          
          echo "✅ Infrastructure changes applied successfully"

      - name: Get Instance IP
        id: get_ip
        run: |
          # Get the output and handle potential errors
          if ! OUTPUT=$(terraform output -json 2>&1); then
            echo "::error::Failed to get Terraform outputs"
            exit 1
          fi
          
          if ! INSTANCE_IP=$(echo "$OUTPUT" | jq -r '.instance_public_ip.value' 2>/dev/null); then
            echo "::error::Failed to parse instance_public_ip from Terraform output"
            echo "Available outputs:"
            echo "$OUTPUT" | jq '.'
            exit 1
          fi
          
          if [ "$INSTANCE_IP" = "null" ] || [ -z "$INSTANCE_IP" ]; then
            echo "::error::instance_public_ip not found in Terraform state"
            echo "Available outputs:"
            echo "$OUTPUT" | jq '.'
            exit 1
          fi
          
          echo "instance_ip=$INSTANCE_IP" >> $GITHUB_OUTPUT
          echo "✅ Successfully retrieved instance IP: $INSTANCE_IP"

      - name: Update PR with Terraform Results
        uses: actions/github-script@v7.0.1
        if: always()
        env:
          PLAN_STATUS: ${{ steps.plan.outcome }}
          APPLY_STATUS: ${{ steps.apply.outcome }}
          INSTANCE_IP: ${{ steps.get_ip.outputs.instance_ip }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const status = process.env.APPLY_STATUS === 'success' ? '✅' : '❌';
            const output = `### Infrastructure Deployment ${status}
            
            **Resources Status:**
            - Infrastructure Apply: ${process.env.APPLY_STATUS === 'success' ? '✅ Success' : '❌ Failed'}
            ${process.env.INSTANCE_IP ? `- Instance IP: \`${process.env.INSTANCE_IP}\`` : ''}`;
            
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              body: output,
              event: 'COMMENT'
            });

      - name: Terraform Plan Status
        if: steps.plan.outcome == 'failure'
        run: exit 1

  deploy_mod:
    needs: [terraform_deploy]
    runs-on: ubuntu-latest
    permissions:
      contents: read        # For checkout
      pull-requests: write  # For commenting results
      id-token: write      # For AWS authentication
      checks: write        # For test results
    steps:
      - name: Configure PR Test Workspace
        id: workspace
        run: |
          PR_NUMBER=$(echo $GITHUB_REF | cut -d'/' -f3)
          WORKSPACE="pr-${PR_NUMBER}"
          echo "workspace=$WORKSPACE" >> $GITHUB_OUTPUT

      - name: Set up AWS CLI
        uses: aws-actions/configure-aws-credentials@v4.0.2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - uses: actions/checkout@v4.1.1
        with:
          repository: LeChienCour/VoiceChatMod
          path: ./mod_source
          ref: main

      - name: Set up JDK 17
        uses: actions/setup-java@v3.13.0
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Build Mod
        id: build
        working-directory: ./mod_source
        run: |
          chmod +x ./gradlew
          ./gradlew build --no-daemon
          
          MOD_JAR=$(find build/libs -type f -name "*.jar" ! -name "*-sources.jar" ! -name "*-dev.jar" | head -n1)
          if [ -z "$MOD_JAR" ]; then
            echo "::error::No mod jar found"
            exit 1
          fi
          echo "mod_jar=$MOD_JAR" >> $GITHUB_OUTPUT

      - name: Get SSH Key from SSM
        id: get_ssh_key
        env:
          WORKSPACE: ${{ steps.workspace.outputs.workspace }}
        run: |
          # Wait for SSM parameter to be available (it's created by Terraform)
          MAX_ATTEMPTS=5
          ATTEMPT=1
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            echo "Attempt $ATTEMPT to retrieve SSH key from SSM..."
            
            # Try to get the parameter
            if SSH_KEY=$(aws ssm get-parameter \
              --name "/minecraft/${WORKSPACE}/ssh_private_key" \
              --with-decryption \
              --query 'Parameter.Value' \
              --output text 2>/dev/null); then
              
              # Store key directly in output
              {
                echo "ssh_key<<EOF"
                echo "$SSH_KEY"
                echo "EOF"
              } >> "$GITHUB_OUTPUT"
              
              echo "Successfully retrieved SSH key from SSM"
              break
            fi
            
            # If we've reached max attempts, fail
            if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
              echo "::error::Failed to retrieve SSH key after $MAX_ATTEMPTS attempts"
              exit 1
            fi
            
            # Wait before next attempt
            echo "Key not found, waiting 10 seconds before retry..."
            sleep 10
            ATTEMPT=$((ATTEMPT + 1))
          done

      - name: Deploy and Verify
        id: deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ needs.terraform_deploy.outputs.instance_ip }}
          username: ubuntu
          key: ${{ steps.get_ssh_key.outputs.ssh_key }}
          port: 22
          script: |
            set -e
            
            # Function to safely truncate logs
            truncate_log() {
              local log_file=$1
              local max_lines=100
              if [ -f "$log_file" ]; then
                local total_lines=$(wc -l < "$log_file")
                if [ $total_lines -gt $max_lines ]; then
                  echo "Log file has $total_lines lines, truncating to last $max_lines lines"
                  tail -n $max_lines "$log_file" > "${log_file}.tmp"
                  mv "${log_file}.tmp" "$log_file"
                fi
              fi
            }
            
            # Cleanup old logs if they exist
            find /opt/minecraft/server/logs -name "*.log" -type f -mtime +7 -delete 2>/dev/null || true
            
            # Check if Minecraft is installed
            if [ ! -d "/opt/minecraft/server" ]; then
              echo "Installing Minecraft server..."
              sudo mkdir -p /opt/minecraft/server
              sudo chown -R ubuntu:ubuntu /opt/minecraft
              cd /opt/minecraft/server
              
              # Install NeoForge
              wget -q https://maven.neoforged.net/releases/net/neoforged/neoforge/1.21.1/neoforge-1.21.1-installer.jar
              java -jar neoforge-1.21.1-installer.jar --installServer
              
              # Basic configuration
              echo "eula=true" > eula.txt
              cat > server.properties << 'EOF'
              server-port=25565
              max-players=20
              difficulty=normal
              gamemode=survival
              EOF
              
              # Setup service
              sudo tee /etc/systemd/system/minecraft.service << 'EOF'
              [Unit]
              Description=Minecraft Server
              After=network.target
              
              [Service]
              WorkingDirectory=/opt/minecraft/server
              User=ubuntu
              Group=ubuntu
              ExecStart=/bin/sh -c 'java -Xmx2G -Xms1G @user_jvm_args.txt @libraries/net/neoforged/forge/1.21.1/unix_args.txt nogui'
              Restart=on-failure
              RestartSec=5
              
              [Install]
              WantedBy=multi-user.target
              EOF
              
              sudo systemctl daemon-reload
              sudo systemctl enable minecraft.service
            fi
            
            cd /opt/minecraft/server
            
            # Stop server if running
            sudo systemctl stop minecraft.service
            
            # Update mod
            mkdir -p mods
            rm -f mods/*.jar
            cp "${{ steps.build.outputs.mod_jar }}" mods/
            
            # Rotate logs before starting
            if [ -f "logs/latest.log" ]; then
              mv logs/latest.log "logs/previous-$(date +%Y%m%d-%H%M%S).log"
            fi
            
            # Start and verify
            sudo systemctl start minecraft.service
            
            # Create a temporary log file for monitoring
            touch /tmp/minecraft_startup.log
            timeout 120 tail -f logs/latest.log | while read line; do
              echo "$line" >> /tmp/minecraft_startup.log
              if echo "$line" | grep -q "Done"; then
                pkill -P $$ tail
                exit 0
              fi
            done
            
            # Check the result
            if grep -q "Done" /tmp/minecraft_startup.log; then
              if systemctl is-active --quiet minecraft.service; then
                # Truncate the success log to avoid large outputs
                truncate_log /tmp/minecraft_startup.log
                echo "::set-output name=status::success"
                echo "::set-output name=message::Server running successfully with mod deployed"
                # Store last 10 lines of successful startup
                tail -n 10 /tmp/minecraft_startup.log > /tmp/startup_summary.log
                echo "::set-output name=startup_log::$(cat /tmp/startup_summary.log | base64 -w 0)"
              else
                echo "::set-output name=status::failure"
                echo "::set-output name=message::Service not running despite successful startup"
                exit 1
              fi
            else
              echo "::set-output name=status::failure"
              echo "::set-output name=message::Server failed to start within timeout"
              # Only capture last 50 lines of error log
              tail -n 50 /tmp/minecraft_startup.log > /tmp/error_summary.log
              echo "::set-output name=error_log::$(cat /tmp/error_summary.log | base64 -w 0)"
              exit 1
            fi
            
            # Cleanup temporary files
            rm -f /tmp/minecraft_startup.log /tmp/startup_summary.log /tmp/error_summary.log

      - name: Report Status
        if: always()
        uses: actions/github-script@v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const status = '${{ steps.deploy.outcome }}' === 'success' ? '✅' : '❌';
            const message = '${{ steps.deploy.outputs.message }}' || 'No status message available';
            const ip = '${{ needs.terraform_deploy.outputs.instance_ip }}';
            
            let logDetails = '';
            if (status === '✅' && '${{ steps.deploy.outputs.startup_log }}') {
              const startupLog = Buffer.from('${{ steps.deploy.outputs.startup_log }}', 'base64').toString();
              logDetails = '\n\n<details><summary>Startup Log</summary>\n\n```\n' + startupLog + '\n```\n</details>';
            } else if (status === '❌' && '${{ steps.deploy.outputs.error_log }}') {
              const errorLog = Buffer.from('${{ steps.deploy.outputs.error_log }}', 'base64').toString();
              logDetails = '\n\n<details><summary>Error Log</summary>\n\n```\n' + errorLog + '\n```\n</details>';
            }
            
            const summary = `### Minecraft Server Deployment ${status}
            
            **Status:** ${status} ${message}
            **Server IP:** \`${ip}\`
            
            ${status === '✅' ? 
              '✅ Server is running and ready to use' : 
              '❌ Deployment encountered issues - check workflow logs for details'
            }${logDetails}`;
            
            // Split long messages if needed
            const maxLength = 65536; // GitHub's comment length limit
            let finalSummary = summary;
            if (summary.length > maxLength) {
              finalSummary = summary.substring(0, maxLength - 3) + '...';
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: finalSummary
            });

      - name: Cleanup
        if: always()
        run: |
          # Securely remove SSH key
          shred -u ~/.ssh/id_rsa

  cleanup_infrastructure:
    needs: [terraform_deploy, deploy_mod]
    if: |
      always() && 
      (
        github.event.action == 'closed' || 
        needs.terraform_deploy.result == 'failure' ||
        needs.deploy_mod.result == 'failure'
      )
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4.1.1

      - name: Set up AWS CLI
        uses: aws-actions/configure-aws-credentials@v4.0.2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3.0.0
        with:
          terraform_version: 1.12.1

      - name: Get Workspace Name
        id: workspace
        run: |
          PR_NUMBER=$(echo $GITHUB_REF | cut -d'/' -f3)
          WORKSPACE="pr-${PR_NUMBER}"
          echo "workspace=$WORKSPACE" >> $GITHUB_OUTPUT

      - name: Terraform Init with Backend Config
        run: |
          # Create backend config
          cat > backend.hcl << EOF
          bucket         = "${{ secrets.TF_STATE_BUCKET }}"
          key            = "pr-environments/${{ steps.workspace.outputs.workspace }}/terraform.tfstate"
          region         = "us-east-1"
          dynamodb_table = "${{ secrets.TF_LOCK_TABLE }}"
          encrypt        = true
          use_lockfile   = true
          EOF

          # Initialize with backend configuration
          terraform init -backend-config=backend.hcl -reconfigure

          # Select workspace
          terraform workspace select ${{ steps.workspace.outputs.workspace }}

      - name: Destroy Infrastructure
        env:
          TF_WORKSPACE: ${{ steps.workspace.outputs.workspace }}
        run: |
          echo "🧹 Cleaning up infrastructure in workspace: $TF_WORKSPACE"
          terraform destroy -auto-approve
          echo "✅ Cleanup completed"

      - name: Delete Workspace
        if: success()
        run: |
          echo "🗑️ Deleting workspace: ${{ steps.workspace.outputs.workspace }}"
          terraform workspace select default
          terraform workspace delete ${{ steps.workspace.outputs.workspace }}

      - name: Notify Cleanup Status
        if: always()
        uses: actions/github-script@v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const status = '${{ job.status }}' === 'success' ? '✅' : '❌';
            const message = `### Infrastructure Cleanup ${status}
            
            ${status === '✅' ? '- Resources successfully cleaned up' : '⚠️ Cleanup encountered issues - manual verification required'}`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: message
            });