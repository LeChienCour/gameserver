name: Pull Request Checks

on:
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened, closed]

# Global minimum permissions
permissions: read-all

jobs:
  terraform_deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read        # For checkout
      pull-requests: write  # For commenting results
      id-token: write      # For AWS authentication
    outputs:
      instance_ip: ${{ steps.get_ip.outputs.instance_ip }}
    steps:
      - uses: actions/checkout@v4.1.1

      - name: Set up AWS CLI
        uses: aws-actions/configure-aws-credentials@v4.0.2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3.0.0
        with:
          terraform_version: 1.12.1

      - name: Validate Required Secrets
        env:
          TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}
          TF_LOCK_TABLE: ${{ secrets.TF_LOCK_TABLE }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          if [ -z "$TF_STATE_BUCKET" ]; then
            echo "::error::TF_STATE_BUCKET secret is not set"
            exit 1
          fi
          if [ -z "$TF_LOCK_TABLE" ]; then
            echo "::error::TF_LOCK_TABLE secret is not set"
            exit 1
          fi
          if [ -z "$AWS_ACCESS_KEY_ID" ]; then
            echo "::error::AWS_ACCESS_KEY_ID secret is not set"
            exit 1
          fi
          if [ -z "$AWS_SECRET_ACCESS_KEY" ]; then
            echo "::error::AWS_SECRET_ACCESS_KEY secret is not set"
            exit 1
          fi
          echo "All required secrets are set"

      - name: Configure PR Test Workspace
        id: workspace
        run: |
          PR_NUMBER=$(echo $GITHUB_REF | cut -d'/' -f3)
          WORKSPACE="pr-${PR_NUMBER}"
          echo "Using workspace: $WORKSPACE"
          echo "workspace=$WORKSPACE" >> $GITHUB_OUTPUT

      - name: Create Backend Config File
        env:
          TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}
          TF_LOCK_TABLE: ${{ secrets.TF_LOCK_TABLE }}
        run: |
          cat > backend.hcl << EOF
          bucket         = "$TF_STATE_BUCKET"
          key            = "pr-environments/${{ steps.workspace.outputs.workspace }}/terraform.tfstate"
          region         = "us-east-1"
          dynamodb_table = "$TF_LOCK_TABLE"
          encrypt        = true
          use_lockfile   = true
          EOF
          
          echo "Generated backend configuration:"
          cat backend.hcl

      - name: Terraform Init with Backend Config
        id: init
        run: |
          # Initialize with backend configuration file
          terraform init -backend-config=backend.hcl -reconfigure 2>&1 | tee init.log

          # Check if init was successful
          if [ $? -ne 0 ]; then
            echo "::error::Terraform init failed"
            exit 1
          fi

          # Create or select workspace
          if ! terraform workspace select ${{ steps.workspace.outputs.workspace }} 2>/dev/null; then
            echo "Creating new workspace: ${{ steps.workspace.outputs.workspace }}"
            terraform workspace new ${{ steps.workspace.outputs.workspace }}
          fi

          echo "INIT_LOG<<EOF" >> $GITHUB_ENV
          cat init.log >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Terraform Format Check
        id: fmt
        run: |
          terraform fmt -check -recursive 2>&1 | tee fmt.log
          echo "FMT_LOG<<EOF" >> $GITHUB_ENV
          cat fmt.log >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Terraform Plan
        id: plan
        env:
          TF_WORKSPACE: ${{ steps.workspace.outputs.workspace }}
        run: |
          terraform plan -no-color -detailed-exitcode -out=tfplan 2>&1 | tee plan.log
          echo "PLAN_LOG<<EOF" >> $GITHUB_ENV
          cat plan.log >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
        continue-on-error: true

      - name: Test Infrastructure Deployment
        id: apply
        if: github.event_name == 'pull_request' && steps.plan.outcome == 'success'
        env:
          TF_WORKSPACE: ${{ steps.workspace.outputs.workspace }}
        run: |
          echo "🚀 Applying test infrastructure changes in workspace: $TF_WORKSPACE"
          terraform apply -auto-approve tfplan 2>&1 | tee apply.log
          echo "APPLY_LOG<<EOF" >> $GITHUB_ENV
          cat apply.log >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Get Instance IP
        id: get_ip
        run: |
          # Wait a moment for the instance to be fully created
          sleep 10
          
          # Get the output and handle potential errors
          if OUTPUT=$(terraform output -json); then
            if echo "$OUTPUT" | jq -e '.instance_public_ip.value' >/dev/null; then
              INSTANCE_IP=$(echo "$OUTPUT" | jq -r '.instance_public_ip.value')
              echo "instance_ip=${INSTANCE_IP}" >> $GITHUB_OUTPUT
              echo "✅ Successfully retrieved instance IP: ${INSTANCE_IP}"
            else
              echo "❌ Error: instance_public_ip output not found in Terraform state"
              echo "Available outputs:"
              echo "$OUTPUT" | jq '.'
              exit 1
            fi
          else
            echo "❌ Error: Failed to get Terraform outputs"
            exit 1
          fi

      - name: Update PR with Terraform Results
        uses: actions/github-script@v7.0.1
        if: always()
        env:
          PLAN_STATUS: ${{ steps.plan.outcome }}
          APPLY_STATUS: ${{ steps.apply.outcome }}
          INSTANCE_IP: ${{ steps.get_ip.outputs.instance_ip }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const status = process.env.APPLY_STATUS === 'success' ? '✅' : '❌';
            const output = `### Infrastructure Deployment ${status}
            
            **Resources Status:**
            - Infrastructure Apply: ${process.env.APPLY_STATUS === 'success' ? '✅ Success' : '❌ Failed'}
            ${process.env.INSTANCE_IP ? `- Instance IP: \`${process.env.INSTANCE_IP}\`` : ''}
            
            ${process.env.APPLY_STATUS !== 'success' ? '⚠️ Check workflow logs for detailed error information.' : ''}`;
            
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              body: output,
              event: 'COMMENT'
            });

      - name: Terraform Plan Status
        if: steps.plan.outcome == 'failure'
        run: exit 1

  build_mod:
    runs-on: ubuntu-latest
    permissions:
      contents: read        # For checkout
      pull-requests: write  # For commenting results
      checks: write        # For test results
      actions: read        # For artifacts
    outputs:
      build_status: ${{ steps.build.outcome }}
      test_status: ${{ steps.test.outcome }}
    steps:
      - uses: actions/checkout@v4.1.1
        with:
          repository: LeChienCour/VoiceChatMod
          path: ./mod_source
          ref: main
          fetch-depth: 0

      - name: Set up JDK 17
        uses: actions/setup-java@v3.13.0
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: none

      - name: Setup Gradle
        uses: gradle/gradle-build-action@v2.11.1
        with:
          gradle-version: 8.14
          cache-read-only: ${{ github.ref != 'refs/heads/main' }}
          gradle-home-cache-cleanup: true
          cache-overwrite-existing: true
          gradle-home-cache-includes: |
            caches/modules-2
            caches/transforms-3
            wrapper
          gradle-home-cache-excludes: |
            caches/build-cache-*
            caches/journal-*
            caches/jars-*
            daemon
            native
          gradle-build-action-cache-timeout-mins: 10
          
      - name: Configure Gradle Properties
        run: |
          mkdir -p ~/.gradle
          cat > ~/.gradle/gradle.properties << EOF
          org.gradle.caching=true
          org.gradle.parallel=true
          org.gradle.daemon=false
          org.gradle.configureondemand=true
          org.gradle.jvmargs=-Xmx2g -XX:MaxMetaspaceSize=512m -XX:+HeapDumpOnOutOfMemoryError
          org.gradle.caching.debug=true
          org.gradle.internal.http.connectionTimeout=120000
          org.gradle.internal.http.socketTimeout=120000
          EOF

      - name: Grant execute permission for gradlew
        run: |
          chmod +x ./mod_source/gradlew

      - name: Build Mod
        id: build
        working-directory: ./mod_source
        run: |
          # Verify Gradle version
          gradle --version
          
          # Build with optimized configuration
          gradle build \
            --no-daemon \
            --build-cache \
            --parallel \
            --stacktrace \
            --info \
            --console=plain \
            -Pmod_version=0.0.1 \
            -Dorg.gradle.caching.debug=true \
            -Dorg.gradle.internal.http.connectionTimeout=120000 \
            -Dorg.gradle.internal.http.socketTimeout=120000
          
          # Verify build output
          if [ -d "build/libs" ]; then
            echo "Build artifacts created:"
            ls -la build/libs/
          else
            echo "Error: No build/libs directory found after build!"
            exit 1
          fi

      - name: Run Tests
        id: test
        if: success()
        run: |
          cd ./mod_source
          ./gradlew test \
            --no-daemon \
            --build-cache \
            --parallel \
            --stacktrace \
            --info \
            --console=plain \
            -Dorg.gradle.caching.debug=true \
            -Dorg.gradle.internal.http.connectionTimeout=120000 \
            -Dorg.gradle.internal.http.socketTimeout=120000 \
            > test_output.log 2>&1
          echo "Test execution completed"

      - name: Update PR with Build Results
        uses: actions/github-script@v7.0.1
        if: always()
        env:
          BUILD_STATUS: ${{ steps.build.outcome }}
          TEST_STATUS: ${{ steps.test.outcome }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const buildStatus = process.env.BUILD_STATUS === 'success' ? '✅' : '❌';
            const testStatus = process.env.TEST_STATUS === 'success' ? '✅' : '❌';
            
            let testDetails = '';
            if (process.env.TEST_STATUS === 'failure') {
              const fs = require('fs');
              try {
                const log = fs.readFileSync('mod_source/test_output.log', 'utf8');
                // Get last 500 characters of log if it failed
                testDetails = '\n\nTest Output (last 500 chars):\n```\n' + 
                  log.slice(-500) + '\n```';
              } catch (error) {
                testDetails = '\n\nError reading test log: ' + error.message;
              }
            }
            
            const output = `### Mod Build Status ${buildStatus}

            **Build Steps:**
            - Build: ${buildStatus}
            - Tests: ${testStatus}${testDetails}
            
            ${process.env.BUILD_STATUS !== 'success' || process.env.TEST_STATUS !== 'success' ? '⚠️ Check workflow logs for detailed error information.' : ''}`;
            
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              body: output,
              event: 'COMMENT'
            });

  deploy_mod:
    needs: [build_mod, terraform_deploy]
    if: needs.build_mod.outputs.build_status == 'success' && needs.build_mod.outputs.test_status == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: read        # For checkout
      pull-requests: write  # For commenting results
      id-token: write      # For AWS authentication
    outputs:
      deployment_status: ${{ steps.verify_deployment.outputs.status }}
    steps:
      - name: Create VoiceChat Config
        id: create_config
        run: |
          mkdir -p VoiceChatMod/runs/client/config
          cat > VoiceChatMod/runs/client/config/voicechat-common.toml << 'EOF'
          enableVoiceChat = true
          defaultVolume = 0.7
          maxVoiceDistance = 64
          reconnectionAttempts = 3
          reconnectionDelay = 5
          websocketStageUrl = "${{ secrets.WEBSOCKET_STAGE_URL }}"
          websocketApiKey = "${{ secrets.WEBSOCKET_API_KEY }}"
          userPoolId = "${{ secrets.USER_POOL_ID }}"
          userPoolClientId = "${{ secrets.USER_POOL_CLIENT_ID }}"
          selectedMicrophone = ""
          useSystemDefaultMic = true
          microphoneBoost = 1.0
          EOF

      - name: Get SSH Key from SSM
        id: get_ssh_key
        run: |
          SSH_KEY=$(aws ssm get-parameter \
            --name "/minecraft/${{ steps.workspace.outputs.workspace }}/ssh_private_key" \
            --with-decryption \
            --query 'Parameter.Value' \
            --output text)
          echo "::add-mask::$SSH_KEY"
          echo "ssh_key<<EOF" >> $GITHUB_OUTPUT
          echo "$SSH_KEY" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Deploy to Server
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ needs.terraform_deploy.outputs.instance_ip }}
          username: ubuntu
          key: ${{ steps.get_ssh_key.outputs.ssh_key }}
          port: 22
          command_timeout: 10m
          script: |
            # Setup directories
            sudo mkdir -p /opt/minecraft/server
            sudo chown -R ubuntu:ubuntu /opt/minecraft
            cd /opt/minecraft/server
            mkdir -p VoiceChatMod/runs/client/config mods
            
            # Download and install Minecraft + NeoForge
            wget -q https://maven.neoforged.net/releases/net/neoforged/neoforge/1.21.1/neoforge-1.21.1-installer.jar
            java -jar neoforge-1.21.1-installer.jar --installServer
            
            # Accept EULA
            echo "eula=true" > eula.txt
            
            # Create server.properties
            cat > server.properties << 'EOF'
            server-port=25565
            max-players=20
            difficulty=normal
            level-name=world
            gamemode=survival
            enable-command-block=true
            motd=Test Minecraft Server
            spawn-protection=0
            EOF
            
            # Create systemd service file
            sudo tee /etc/systemd/system/minecraft.service << 'EOF'
            [Unit]
            Description=Minecraft Server
            After=network.target
            
            [Service]
            WorkingDirectory=/opt/minecraft/server
            User=ubuntu
            Group=ubuntu
            
            ExecStart=/bin/sh -c 'java -Xmx2G -Xms1G @user_jvm_args.txt @libraries/net/neoforged/forge/1.21.1/unix_args.txt nogui'
            
            Restart=on-failure
            RestartSec=5
            
            [Install]
            WantedBy=multi-user.target
            EOF
            
            # Create config file
            cat > VoiceChatMod/runs/client/config/voicechat-common.toml << 'EOF'
            enableVoiceChat = true
            defaultVolume = 0.7
            maxVoiceDistance = 64
            reconnectionAttempts = 3
            reconnectionDelay = 5
            websocketStageUrl = "${{ secrets.WEBSOCKET_STAGE_URL }}"
            websocketApiKey = "${{ secrets.WEBSOCKET_API_KEY }}"
            userPoolId = "${{ secrets.USER_POOL_ID }}"
            userPoolClientId = "${{ secrets.USER_POOL_CLIENT_ID }}"
            selectedMicrophone = ""
            useSystemDefaultMic = true
            microphoneBoost = 1.0
            EOF
            
            # Reload systemd and start service
            sudo systemctl daemon-reload
            sudo systemctl enable minecraft.service
            sudo systemctl start minecraft.service
            
            # Wait for server to start and check logs
            sleep 30
            if ! grep -q "Done" logs/latest.log 2>/dev/null; then
              echo "Server failed to start properly"
              cat logs/latest.log
              exit 1
            fi

      - name: Verify Deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ needs.terraform_deploy.outputs.instance_ip }}
          username: ubuntu
          key: ${{ secrets.EC2_SSH_PRIVATE_KEY }}
          script: |
            cd /opt/minecraft/server
            
            # Service check
            if ! sudo systemctl is-active --quiet minecraft.service; then
              echo "❌ Service check failed"
              exit 1
            fi
            
            # Mod check
            if ! ls mods/*VoiceChat*.jar >/dev/null 2>&1; then
              echo "❌ Mod check failed"
              exit 1
            fi
            
            # Config check
            if ! [ -f VoiceChatMod/runs/client/config/voicechat-common.toml ]; then
              echo "❌ Config check failed"
              exit 1
            fi
            
            # Log check
            if ! grep -q "VoiceChat mod initialized" logs/latest.log; then
              echo "❌ Mod initialization failed"
              tail -n 50 logs/latest.log
              exit 1
            fi
            
            echo "✅ All checks passed"

      - name: Set Deployment Status
        id: set_status
        if: always()
        run: |
          if [ "${{ steps.verify_deployment.outcome }}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
          fi

      - name: Update PR with Verification Results
        uses: actions/github-script@v7.0.1
        if: always()
        env:
          VERIFICATION_OUTCOME: ${{ steps.verify_deployment.outcome }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const status = process.env.VERIFICATION_OUTCOME === 'success' ? '✅ Success' : '❌ Failed';
            const output = `### Deployment Verification Results ${status}
            
            ${process.env.VERIFICATION_OUTCOME === 'success' 
              ? '- All components verified successfully\n- Server is running\n- Mod is installed\n- Configuration is correct\n- Mod initialized properly' 
              : '- Verification failed. Check the workflow logs for details'}
            
            *Workflow: [${context.workflow}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})*`;
            
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              body: output,
              event: 'COMMENT'
            });

  cleanup_infrastructure:
    needs: [terraform_deploy, build_mod, deploy_mod]
    if: |
      always() && 
      (
        github.event.action == 'closed' || 
        needs.terraform_deploy.result == 'failure' ||
        needs.build_mod.outputs.build_status == 'failure' ||
        needs.build_mod.outputs.test_status == 'failure' ||
        needs.deploy_mod.result == 'failure'
      )
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4.1.1

      - name: Set up AWS CLI
        uses: aws-actions/configure-aws-credentials@v4.0.2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3.0.0
        with:
          terraform_version: 1.12.1

      - name: Get Workspace Name
        id: workspace
        run: |
          PR_NUMBER=$(echo $GITHUB_REF | cut -d'/' -f3)
          WORKSPACE="pr-${PR_NUMBER}"
          echo "workspace=$WORKSPACE" >> $GITHUB_OUTPUT

      - name: Terraform Init with Backend Config
        run: |
          # Create backend config
          cat > backend.hcl << EOF
          bucket         = "${{ secrets.TF_STATE_BUCKET }}"
          key            = "pr-environments/${{ steps.workspace.outputs.workspace }}/terraform.tfstate"
          region         = "us-east-1"
          dynamodb_table = "${{ secrets.TF_LOCK_TABLE }}"
          encrypt        = true
          use_lockfile   = true
          EOF

          # Initialize with backend configuration
          terraform init -backend-config=backend.hcl -reconfigure

          # Select workspace
          terraform workspace select ${{ steps.workspace.outputs.workspace }}

      - name: Destroy Infrastructure
        env:
          TF_WORKSPACE: ${{ steps.workspace.outputs.workspace }}
        run: |
          echo "🧹 Cleaning up infrastructure in workspace: $TF_WORKSPACE"
          terraform destroy -auto-approve
          echo "✅ Cleanup completed"

      - name: Delete Workspace
        if: success()
        run: |
          echo "🗑️ Deleting workspace: ${{ steps.workspace.outputs.workspace }}"
          terraform workspace select default
          terraform workspace delete ${{ steps.workspace.outputs.workspace }}

      - name: Notify Cleanup Status
        if: always()
        uses: actions/github-script@v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const status = '${{ job.status }}' === 'success' ? '✅' : '❌';
            const message = `### Infrastructure Cleanup ${status}
            
            ${status === '✅' ? '- Resources successfully cleaned up' : '⚠️ Cleanup encountered issues - manual verification required'}`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: message
            });