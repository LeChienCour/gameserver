name: Pull Request Checks

on:
  pull_request:
    branches:
      - main
    types: [opened, synchronize, reopened, closed]

# Global minimum permissions
permissions: read-all

jobs:
  terraform_deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read        # For checkout
      pull-requests: write  # For commenting results
      id-token: write      # For AWS authentication
    outputs:
      instance_ip: ${{ steps.get_ip.outputs.instance_ip }}
    steps:
      - uses: actions/checkout@v4.1.1

      - name: Set up AWS CLI
        uses: aws-actions/configure-aws-credentials@v4.0.2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3.0.0
        with:
          terraform_version: 1.12.1

      - name: Validate Required Secrets
        env:
          TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}
          TF_LOCK_TABLE: ${{ secrets.TF_LOCK_TABLE }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        run: |
          if [ -z "$TF_STATE_BUCKET" ]; then
            echo "::error::TF_STATE_BUCKET secret is not set"
            exit 1
          fi
          if [ -z "$TF_LOCK_TABLE" ]; then
            echo "::error::TF_LOCK_TABLE secret is not set"
            exit 1
          fi
          if [ -z "$AWS_ACCESS_KEY_ID" ]; then
            echo "::error::AWS_ACCESS_KEY_ID secret is not set"
            exit 1
          fi
          if [ -z "$AWS_SECRET_ACCESS_KEY" ]; then
            echo "::error::AWS_SECRET_ACCESS_KEY secret is not set"
            exit 1
          fi
          echo "All required secrets are set"

      - name: Configure PR Test Workspace
        id: workspace
        run: |
          PR_NUMBER=$(echo $GITHUB_REF | cut -d'/' -f3)
          WORKSPACE="pr-${PR_NUMBER}"
          echo "Using workspace: $WORKSPACE"
          echo "workspace=$WORKSPACE" >> $GITHUB_OUTPUT

      - name: Create Backend Config File
        env:
          TF_STATE_BUCKET: ${{ secrets.TF_STATE_BUCKET }}
          TF_LOCK_TABLE: ${{ secrets.TF_LOCK_TABLE }}
        run: |
          cat > backend.hcl << EOF
          bucket         = "$TF_STATE_BUCKET"
          key            = "pr-environments/${{ steps.workspace.outputs.workspace }}/terraform.tfstate"
          region         = "us-east-1"
          dynamodb_table = "$TF_LOCK_TABLE"
          encrypt        = true
          use_lockfile   = true
          EOF
          
          echo "Generated backend configuration:"
          cat backend.hcl

      - name: Terraform Init with Backend Config
        id: init
        run: |
          # Initialize with backend configuration file
          terraform init -backend-config=backend.hcl -reconfigure 2>&1 | tee init.log

          # Check if init was successful
          if [ $? -ne 0 ]; then
            echo "::error::Terraform init failed"
            exit 1
          fi

          # Create or select workspace
          if ! terraform workspace select ${{ steps.workspace.outputs.workspace }} 2>/dev/null; then
            echo "Creating new workspace: ${{ steps.workspace.outputs.workspace }}"
            terraform workspace new ${{ steps.workspace.outputs.workspace }}
          fi

          echo "INIT_LOG<<EOF" >> $GITHUB_ENV
          cat init.log >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Terraform Format Check
        id: fmt
        run: |
          terraform fmt -check -recursive 2>&1 | tee fmt.log
          echo "FMT_LOG<<EOF" >> $GITHUB_ENV
          cat fmt.log >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Terraform Plan
        id: plan
        env:
          TF_WORKSPACE: ${{ steps.workspace.outputs.workspace }}
        run: |
          terraform plan -no-color -detailed-exitcode -out=tfplan 2>&1 | tee plan.log
          echo "PLAN_LOG<<EOF" >> $GITHUB_ENV
          cat plan.log >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV
        continue-on-error: true

      - name: Test Infrastructure Deployment
        id: apply
        if: github.event_name == 'pull_request' && steps.plan.outcome == 'success'
        env:
          TF_WORKSPACE: ${{ steps.workspace.outputs.workspace }}
        run: |
          echo "üöÄ Applying test infrastructure changes in workspace: $TF_WORKSPACE"
          terraform apply -auto-approve tfplan 2>&1 | tee apply.log
          echo "APPLY_LOG<<EOF" >> $GITHUB_ENV
          cat apply.log >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Get Instance IP
        id: get_ip
        run: |
          # Wait a moment for the instance to be fully created
          sleep 10
          
          # Get the output and handle potential errors
          if OUTPUT=$(terraform output -json); then
            if echo "$OUTPUT" | jq -e '.instance_public_ip.value' >/dev/null; then
              INSTANCE_IP=$(echo "$OUTPUT" | jq -r '.instance_public_ip.value')
              echo "instance_ip=${INSTANCE_IP}" >> $GITHUB_OUTPUT
              echo "‚úÖ Successfully retrieved instance IP: ${INSTANCE_IP}"
            else
              echo "‚ùå Error: instance_public_ip output not found in Terraform state"
              echo "Available outputs:"
              echo "$OUTPUT" | jq '.'
              exit 1
            fi
          else
            echo "‚ùå Error: Failed to get Terraform outputs"
            exit 1
          fi

      - name: Update PR with Terraform Results
        uses: actions/github-script@v7.0.1
        if: always()
        env:
          PLAN_STATUS: ${{ steps.plan.outcome }}
          APPLY_STATUS: ${{ steps.apply.outcome }}
          INSTANCE_IP: ${{ steps.get_ip.outputs.instance_ip }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const status = process.env.APPLY_STATUS === 'success' ? '‚úÖ' : '‚ùå';
            const output = `### Infrastructure Deployment ${status}
            
            **Resources Status:**
            - Infrastructure Apply: ${process.env.APPLY_STATUS === 'success' ? '‚úÖ Success' : '‚ùå Failed'}
            ${process.env.INSTANCE_IP ? `- Instance IP: \`${process.env.INSTANCE_IP}\`` : ''}
            
            ${process.env.APPLY_STATUS !== 'success' ? '‚ö†Ô∏è Check workflow logs for detailed error information.' : ''}`;
            
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              body: output,
              event: 'COMMENT'
            });

      - name: Terraform Plan Status
        if: steps.plan.outcome == 'failure'
        run: exit 1

  build_mod:
    runs-on: ubuntu-latest
    permissions:
      contents: read        # For checkout
      pull-requests: write  # For commenting results
      checks: write        # For test results
      actions: read        # For artifacts
    steps:
      - uses: actions/checkout@v4.1.1
        with:
          repository: LeChienCour/VoiceChatMod
          path: ./mod_source
          ref: main
          fetch-depth: 0

      - name: Set up JDK 17
        uses: actions/setup-java@v3.13.0
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: gradle

      - name: Setup Gradle
        uses: gradle/gradle-build-action@v2.11.1
        with:
          gradle-version: 8.14
          gradle-home-cache-cleanup: true

      - name: Grant execute permission for gradlew
        run: |
          chmod +x ./mod_source/gradlew

      - name: Build Mod
        id: build
        working-directory: ./mod_source
        run: |
          # Print working directory and files
          pwd
          ls -la
          
          # Print Gradle project info
          gradle properties --no-daemon | grep "mod_version" || echo "mod_version not found in properties"
          
          # Try building with explicit project directory
          gradle build --project-dir . --stacktrace --info

      - name: Run Tests
        id: test
        if: success()
        run: |
          cd ./mod_source
          ./gradlew --no-daemon test --stacktrace --info | tee test.log
          echo "TEST_LOG<<EOF" >> $GITHUB_ENV
          cat test.log >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: mod-jar
          path: |
            ./mod_source/build/libs/*.jar
            !./mod_source/build/libs/*-sources.jar
            !./mod_source/build/libs/*-javadoc.jar
          if-no-files-found: error

      - name: Update PR with Build Results
        uses: actions/github-script@v7.0.1
        if: always()
        env:
          BUILD_STATUS: ${{ steps.build.outcome }}
          TEST_STATUS: ${{ steps.test.outcome }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const buildStatus = process.env.BUILD_STATUS === 'success' ? '‚úÖ' : '‚ùå';
            const testStatus = process.env.TEST_STATUS === 'success' ? '‚úÖ' : '‚ùå';
            
            const output = `### Mod Build Status ${buildStatus}

            **Build Steps:**
            - Build: ${buildStatus}
            - Tests: ${testStatus}
            
            ${process.env.BUILD_STATUS !== 'success' || process.env.TEST_STATUS !== 'success' ? '‚ö†Ô∏è Check workflow logs for detailed error information.' : ''}`;
            
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              body: output,
              event: 'COMMENT'
            });

  deploy_mod:
    needs: [build_mod, terraform_deploy]
    runs-on: ubuntu-latest
    permissions:
      contents: read        # For checkout
      pull-requests: write  # For commenting results
      id-token: write      # For AWS authentication
    outputs:
      deployment_status: ${{ steps.verify_deployment.outputs.status }}
    steps:
      - name: Wait for EC2 Instance
        run: |
          echo "Waiting 60 seconds for EC2 instance to initialize..."
          sleep 60
      
      - name: Deploy and Configure Server
        id: deploy
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ needs.terraform_deploy.outputs.instance_ip }}
          username: ubuntu
          key: ${{ secrets.EC2_PRIVATE_KEY }}
          script: |
            {
              echo "::group::Server Setup"
              sudo mkdir -p /opt/minecraft/server
              sudo chown -R ubuntu:ubuntu /opt/minecraft
              cd /opt/minecraft/server
              
              echo "Downloading NeoForge..."
              wget -q https://maven.neoforged.net/releases/net/neoforged/neoforge/1.21.1/neoforge-1.21.1-installer.jar
              
              echo "Installing NeoForge..."
              java -jar neoforge-1.21.1-installer.jar --installServer
              
              echo "Creating mods directory..."
              mkdir -p mods
              mkdir -p config/voicechat
              echo "::endgroup::"
              
              echo "::group::Mod Deployment"
              echo "Downloading mod from S3..."
              aws s3 cp s3://${{ secrets.MOD_ARTIFACT_BUCKET }}/${{ needs.build_mod.outputs.mod_path }} mods/
              echo "Mod files in directory:"
              ls -la mods/
              echo "::endgroup::"

              echo "::group::VoiceChat Configuration"
              echo "Configuring VoiceChat mod..."
              cat > config/voicechat/voicechatmod-common.toml << EOF
              [voice]
              # The host name of the voice chat server
              server_host = "${{ secrets.VOICECHAT_SERVER_HOST }}"
              # The port of the voice chat server
              server_port = ${{ secrets.VOICECHAT_SERVER_PORT }}
              # The codec used for audio transmission
              codec = "OPUS"
              # The MTU size used for audio transmission
              mtu_size = 1024
              # The sample rate of recorded audio
              sample_rate = 48000
              # The keep alive time in seconds
              keep_alive = 30
              # The maximum audio packet size in bytes
              max_packet_size = 32768
              # Whether to use native audio backend
              native_audio = true
              # Whether to enable microphone testing
              microphone_testing = true
              # The microphone amplification
              microphone_amplification = 1.0
              # The recording buffer size
              recording_buffer_size = 1000
              # The recording destination
              recording_destination = "VOICE_CHAT"
              # The group type
              group_type = "OPEN"
              # Whether to enable voice activation
              voice_activation = false
              # The voice activation threshold
              voice_activation_threshold = 0.0
              # Whether to enable voice chat
              voice_chat_enabled = true
              # Whether to enable voice chat volume adjustment
              voice_chat_volume = 1.0
              # Whether to enable voice chat icons
              voice_chat_icons = true
              EOF
              
              echo "VoiceChat configuration created:"
              cat config/voicechat/voicechatmod-common.toml
              echo "::endgroup::"
              
              echo "::group::Service Configuration"
              echo "Enabling and starting Minecraft service..."
              sudo systemctl enable minecraft.service
              sudo systemctl start minecraft.service
              echo "Service status:"
              sudo systemctl status minecraft.service
              echo "::endgroup::"
            } 2>&1 | tee deployment.log

      - name: Verify Deployment
        id: verify_deployment
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ needs.terraform_deploy.outputs.instance_ip }}
          username: ubuntu
          key: ${{ secrets.EC2_PRIVATE_KEY }}
          script: |
            {
              echo "::group::Service Status Check"
              # Check if Minecraft service is running
              if ! sudo systemctl is-active --quiet minecraft.service; then
                echo "‚ùå Minecraft service is not running"
                exit 1
              fi
              echo "‚úÖ Minecraft service is running"
              echo "::endgroup::"

              echo "::group::Mod Check"
              # Check if mod is properly installed
              cd /opt/minecraft/server
              if ! ls mods/*VoiceChat*.jar >/dev/null 2>&1; then
                echo "‚ùå VoiceChat mod not found in mods directory"
                exit 1
              fi
              echo "‚úÖ VoiceChat mod is installed"
              echo "::endgroup::"

              echo "::group::Config Check"
              # Check if config file exists and has correct settings
              if [ ! -f config/voicechat/voicechatmod-common.toml ]; then
                echo "‚ùå VoiceChat config file not found"
                exit 1
              fi
              
              # Verify essential config settings
              if ! grep -q "server_host = \"${{ secrets.VOICECHAT_SERVER_HOST }}\"" config/voicechat/voicechatmod-common.toml; then
                echo "‚ùå VoiceChat server host configuration is incorrect"
                exit 1
              fi
              
              if ! grep -q "server_port = ${{ secrets.VOICECHAT_SERVER_PORT }}" config/voicechat/voicechatmod-common.toml; then
                echo "‚ùå VoiceChat server port configuration is incorrect"
                exit 1
              fi
              echo "‚úÖ VoiceChat configuration is correct"
              echo "::endgroup::"

              echo "::group::Server Log Check"
              # Check server logs for successful mod loading
              if ! grep -q "VoiceChat mod initialized" logs/latest.log 2>/dev/null; then
                echo "‚ùå VoiceChat mod initialization not found in logs"
                echo "Last 50 lines of server log:"
                tail -n 50 logs/latest.log
                exit 1
              fi
              echo "‚úÖ VoiceChat mod initialized successfully"
              echo "::endgroup::"

              echo "All checks passed successfully! ‚úÖ"
            } 2>&1 | tee verification.log
        continue-on-error: true

      - name: Set Deployment Status
        id: set_status
        if: always()
        run: |
          if [ "${{ steps.verify_deployment.outcome }}" = "success" ]; then
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "status=failure" >> $GITHUB_OUTPUT
          fi

      - name: Update PR with Verification Results
        uses: actions/github-script@v7.0.1
        if: always()
        env:
          VERIFICATION_OUTCOME: ${{ steps.verify_deployment.outcome }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const status = process.env.VERIFICATION_OUTCOME === 'success' ? '‚úÖ Success' : '‚ùå Failed';
            const output = `### Deployment Verification Results ${status}
            
            ${process.env.VERIFICATION_OUTCOME === 'success' 
              ? '- All components verified successfully\n- Server is running\n- Mod is installed\n- Configuration is correct\n- Mod initialized properly' 
              : '- Verification failed. Check the workflow logs for details'}
            
            *Workflow: [${context.workflow}](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})*`;
            
            await github.rest.pulls.createReview({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number,
              body: output,
              event: 'COMMENT'
            });

  cleanup_infrastructure:
    needs: [terraform_deploy, build_mod, deploy_mod]
    if: |
      always() && 
      (
        github.event.action == 'closed' || 
        needs.terraform_deploy.result == 'failure' ||
        needs.build_mod.result == 'failure' ||
        needs.deploy_mod.result == 'failure'
      )
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4.1.1

      - name: Set up AWS CLI
        uses: aws-actions/configure-aws-credentials@v4.0.2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v3.0.0
        with:
          terraform_version: 1.12.1

      - name: Get Workspace Name
        id: workspace
        run: |
          PR_NUMBER=$(echo $GITHUB_REF | cut -d'/' -f3)
          WORKSPACE="pr-${PR_NUMBER}"
          echo "workspace=$WORKSPACE" >> $GITHUB_OUTPUT

      - name: Terraform Init with Backend Config
        run: |
          # Create backend config
          cat > backend.hcl << EOF
          bucket         = "${{ secrets.TF_STATE_BUCKET }}"
          key            = "pr-environments/${{ steps.workspace.outputs.workspace }}/terraform.tfstate"
          region         = "us-east-1"
          dynamodb_table = "${{ secrets.TF_LOCK_TABLE }}"
          encrypt        = true
          use_lockfile   = true
          EOF

          # Initialize with backend configuration
          terraform init -backend-config=backend.hcl -reconfigure

          # Select workspace
          terraform workspace select ${{ steps.workspace.outputs.workspace }}

      - name: Destroy Infrastructure
        env:
          TF_WORKSPACE: ${{ steps.workspace.outputs.workspace }}
        run: |
          echo "üßπ Cleaning up infrastructure in workspace: $TF_WORKSPACE"
          terraform destroy -auto-approve
          echo "‚úÖ Cleanup completed"

      - name: Delete Workspace
        if: success()
        run: |
          echo "üóëÔ∏è Deleting workspace: ${{ steps.workspace.outputs.workspace }}"
          terraform workspace select default
          terraform workspace delete ${{ steps.workspace.outputs.workspace }}

      - name: Notify Cleanup Status
        if: always()
        uses: actions/github-script@v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const status = '${{ job.status }}' === 'success' ? '‚úÖ' : '‚ùå';
            const message = `### Infrastructure Cleanup ${status}
            
            ${status === '‚úÖ' ? '- Resources successfully cleaned up' : '‚ö†Ô∏è Cleanup encountered issues - manual verification required'}`;
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: message
            });